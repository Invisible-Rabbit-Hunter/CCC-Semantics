import CCCSemantics.Categories.CartesianClosed
import CCCSemantics.Categories.CartesianClosed.Types
import CCCSemantics.Lambda.Reduction

open Categories Cartesian CartesianClosed
variable [CartesianClosed ùíû]

def interpTy (base : Œ± ‚Üí ùíû) : Ty Œ± ‚Üí ùíû
| .base b => base b
| .arr a b => exp (interpTy base a) (interpTy base b)
| .prod a b => prod (interpTy base a) (interpTy base b)
| .unit => Cartesian.final

structure Struct (œÉ : Sig) (ùíû) [CartesianClosed ùíû] where
  types : œÉ.types ‚Üí ùíû
  terms (t : œÉ.terms) : final ‚ü∂ interpTy types (œÉ.typing t)

notation "‚ü¶" œÑ "‚üßTy[" œÉ "]" => interpTy (Struct.types œÉ) œÑ

section
variable [CartesianClosed ùíû] (Str : Struct œÉ ùíû)

def interpCtx : Ctx œÉ ‚Üí ùíû
| Œµ      => final
| Œì ,, œÑ => interpCtx Œì √ó' (interpTy Str.types œÑ)

notation "‚ü¶" Œì "‚üßCtx[" s "]" => interpCtx s Œì

def interpVar : ‚àÄ {Œì : Ctx œÉ}, Var œÑ Œì ‚Üí interpCtx Str Œì ‚ü∂ interpTy Str.types œÑ
| _ ,, _, .zero => proj‚ÇÇ
| _ ,, _, .succ v => interpVar v ‚äö proj‚ÇÅ

notation "‚ü¶" v "‚üßVar[" s "]" => interpVar s v

def interpTm :
  Œì ‚ä¢ œÑ ‚Üí (interpCtx Str Œì ‚ü∂ interpTy Str.types œÑ)
| .var v    => interpVar Str v
| .base b   => Str.terms b ‚äö bang
| .lam t    => lam (interpTm t)
| .app t u  => eval ‚äö pair (interpTm t) (interpTm u)
| .pair t u => pair (interpTm t) (interpTm u)
| .fst t    => proj‚ÇÅ ‚äö interpTm t
| .snd t    => proj‚ÇÇ ‚äö interpTm t
| .unit     => bang

notation "‚ü¶" t "‚üßTm[" s "]" => interpTm s t

def interpRenaming :
  Renaming Œì Œî ‚Üí (interpCtx Str Œì ‚ü∂ interpCtx Str Œî)
| .nil      => bang
| .cons r v => pair (interpRenaming r) (interpVar Str v)

notation "‚ü¶" r "‚üßRen[" s "]" => interpRenaming s r

theorem interpVar_renaming : ‚àÄ (v : Var œÑ Œî) (r : Renaming Œì Œî),
  ‚ü¶ v.rename r ‚üßVar[Str] = ‚ü¶ v ‚üßVar[Str] ‚äö ‚ü¶ r ‚üßRen[Str]
| .zero,   .cons r v => (proj‚ÇÇ_pair _ _).symm
| .succ v, .cons r _ => by rw [Var.rename, interpVar,
                               interpRenaming, Category.assoc _ proj‚ÇÅ,
                               proj‚ÇÅ_pair, interpVar_renaming]

@[simp]
theorem interpRenaming_drop : ‚àÄ (r : Renaming Œì Œî),
  ‚ü¶ r.drop œÑ ‚üßRen[Str] = ‚ü¶ r ‚üßRen[Str] ‚äö proj‚ÇÅ
| .nil      => (bang_unique _).symm
| .cons r v => by
  apply pair_unique
  rw [‚ÜêCategory.assoc, interpRenaming, proj‚ÇÅ_pair, interpRenaming_drop]
  rw [‚ÜêCategory.assoc, interpRenaming, proj‚ÇÇ_pair, interpVar]

@[simp]
theorem interpRenaming_ide : ‚àÄ Œì : Ctx œÉ, ‚ü¶ Renaming.ide Œì ‚üßRen[ Str ] = ùüô ‚ü¶Œì‚üßCtx[Str]
| Œµ      => (bang_unique _).symm
| Œì ,, œÑ => by
  simp [interpRenaming, interpVar, interpCtx]
  rw [interpRenaming_ide Œì]
  simp

theorem interpTm_renaming : ‚àÄ (t : Œî ‚ä¢ œÑ) (r : Renaming Œì Œî),
  ‚ü¶ t.rename r ‚üßTm[Str] = ‚ü¶ t ‚üßTm[Str] ‚äö ‚ü¶ r ‚üßRen[Str]
| .var  v,   r => interpVar_renaming Str v r
| .base b,   r => ((Category.assoc _ _ _).trans
                   (congrArg (_‚äö¬∑) (bang_unique _))).symm
| .lam  t,   r => by
    simp [Tm.rename, interpTm]
    rw [interpTm_renaming t]
    simp [interpRenaming, interpVar]
    rw [‚ÜêCategory.id_compose proj‚ÇÇ, ‚Üêprod.map, prod.lam_of_comp]
| .app  t u, r => by simp [Tm.rename, interpTm]
                     rw [interpTm_renaming t, interpTm_renaming u, pair_comp]
| .pair t u, r => by simp [Tm.rename, interpTm]
                     rw [interpTm_renaming t, interpTm_renaming u, pair_comp]
| .fst  t,   r => by simp [Tm.rename, interpTm]; rw [interpTm_renaming t]
| .snd  t,   r => by simp [Tm.rename, interpTm]; rw [interpTm_renaming t]
| .unit,     r => (bang_unique _).symm

def interpSubst :
  Subst Œì Œî ‚Üí (interpCtx Str Œì ‚ü∂ interpCtx Str Œî)
| .nil      => bang
| .cons s t => pair (interpSubst s) (interpTm Str t)

notation "‚ü¶" s "‚üßSub[" str "]" => interpSubst str s

theorem interpVar_subst : ‚àÄ (v : Var œÑ Œî) (s : Subst Œì Œî) ,
  ‚ü¶ v.subst s ‚üßTm[Str] = ‚ü¶ v ‚üßVar[Str] ‚äö interpSubst Str s
| .zero,   .cons _ t => by simp [Var.subst, interpSubst, interpVar]
| .succ v, .cons s _ => by simp [Var.subst, interpSubst, interpVar, interpVar_subst]

theorem interpSubst_drop : ‚àÄ (s : Subst Œì Œî),
  ‚ü¶ s.drop œÑ ‚üßSub[Str] = ‚ü¶ s ‚üßSub[Str] ‚äö proj‚ÇÅ
| .nil      => (bang_unique _).symm
| .cons s t => by
  simp [Subst.drop, interpSubst]
  apply pair_unique
  rw [‚ÜêCategory.assoc, proj‚ÇÅ_pair, interpSubst_drop]
  rw [‚ÜêCategory.assoc, proj‚ÇÇ_pair, interpTm_renaming, interpRenaming_drop]
  simp

theorem interpTm_subst : ‚àÄ (t : Œî ‚ä¢ œÑ) (s : Subst Œì Œî),
  interpTm Str (t.subst s) = interpTm Str t ‚äö interpSubst Str s
| .var v,    s => interpVar_subst Str v s
| .base b,   s => by
  simp [interpTm]
  congr
  exact (bang_unique _).symm
| .lam t,    s => by
  simp [interpTm]
  apply Eq.symm
  apply lam_unique
  simp [interpTm_subst, interpSubst, interpTm, interpVar]
  rw [prod.map_comp_fst, ‚ÜêCategory.assoc, eval_lam]
  simp [prod.map, interpSubst_drop]
| .app t u,  s => by simp [interpTm, Tm.subst, interpTm_subst]
| .pair t u, s => by simp [interpTm, Tm.subst, interpTm_subst]
| .fst t,    s => by simp [interpTm, Tm.subst, interpTm_subst]
| .snd t,    s => by simp [interpTm, Tm.subst, interpTm_subst]
| .unit,     s => (bang_unique _).symm

@[simp]
theorem interpSubst_ofRenaming : ‚àÄ (r : Renaming Œì Œî),
  ‚ü¶ Subst.ofRenaming r ‚üßSub[Str] = ‚ü¶ r ‚üßRen[Str]
| .nil      => (bang_unique _).symm
| .cons r v => by
  simp [interpSubst, interpRenaming]
  apply pair_unique
  simp [interpSubst_ofRenaming r]
  simp [interpTm]
  
@[simp]
theorem interpSubst_ide : ‚àÄ Œì : Ctx œÉ, ‚ü¶ Subst.ide Œì ‚üßSub[ Str ] = ùüô ‚ü¶Œì‚üßCtx[Str] := by
  simp [Subst.ide]

theorem interpTm_preserves_equiv : t ‚âà t' ‚Üí
  ‚ü¶ t ‚üßTm[Str] = ‚ü¶ t' ‚üßTm[Str] := by
    intro r
    induction r with
    | refl t                 => rfl
    | symm _ ih              => exact ih.symm
    | trans _ _ ih‚ÇÅ ih‚ÇÇ      => exact ih‚ÇÅ.trans ih‚ÇÇ
    | app_congr _ _ ih‚ÇÅ ih‚ÇÇ  => exact congrArg‚ÇÇ (eval ‚äö pair ¬∑ ¬∑) ih‚ÇÅ ih‚ÇÇ
    | lam_congr _ ih         => exact congrArg lam ih
    | pair_congr _ _ ih‚ÇÅ ih‚ÇÇ => exact congrArg‚ÇÇ pair ih‚ÇÅ ih‚ÇÇ
    | fst_congr _ ih         => exact congrArg (proj‚ÇÅ ‚äö ¬∑) ih
    | snd_congr _ ih         => exact congrArg (proj‚ÇÇ ‚äö ¬∑) ih
    | arr_Œ≤                  => simp [interpTm, interpTm_subst, interpSubst]
                                rw [eval_pair_lam]
    | arr_Œ∑                  => simp [interpTm, interpTm_subst, interpSubst]
                                apply lam_unique
                                simp [interpTm_renaming, interpVar, prod.map]
    | prod_Œ≤‚ÇÅ                => simp [interpTm]
    | prod_Œ≤‚ÇÇ                => simp [interpTm]
    | prod_Œ∑                 => simp [interpTm]
                                apply Eq.symm
                                apply Category.id_compose
    | unit_Œ∑                 => apply bang_unique

theorem interpSubst_preserves_equiv : s ‚âà s' ‚Üí
  ‚ü¶ s ‚üßSub[Str] = ‚ü¶s'‚üßSub[Str] := by
    intro r
    induction r with
    | nil => rfl
    | cons _ rt ih =>
      apply congrArg‚ÇÇ pair
      exact ih
      exact interpTm_preserves_equiv _ rt

theorem interpSubst_comp : ‚ü¶ s‚ÇÅ.comp s‚ÇÇ ‚üßSub[Str] = ‚ü¶s‚ÇÅ‚üßSub[Str] ‚äö ‚ü¶s‚ÇÇ‚üßSub[Str] := by
  induction s‚ÇÅ with
  | nil => apply Eq.symm; apply bang_unique
  | cons s‚ÇÅ t ih =>
    simp [Subst.comp, interpSubst, ih, interpTm_subst]


def TmQ (Œì : Ctx œÉ) œÑ := Quotient (instSetoidTm Œì œÑ)

def Syn (Œì Œî : Ctx œÉ) := Quotient (instSetoidSubst Œì Œî)

def Syn.nil : Syn Œì Œµ := Quotient.mk' .nil

def Syn.cons : Syn Œì Œî ‚Üí TmQ Œì œÑ ‚Üí Syn Œì (Œî ,, œÑ) :=
  Quotient.lift‚ÇÇ (Œª s t => Quotient.mk' (Subst.cons s t)) $ by
    intro s‚ÇÅ t‚ÇÅ s‚ÇÇ t‚ÇÇ e‚Çõ e‚Çú
    apply Quotient.sound
    apply SubEquiv.cons <;> assumption

-- theorem Syn.cons_lift : Syn Œì Œî ‚Üí TmQ Œì œÑ ‚Üí Syn Œì (Œî ,, œÑ) :=
--   Quotient.lift‚ÇÇ (Œª s t => Quotient.mk' (Subst.cons s t)) $ by
--     intro s‚ÇÅ t‚ÇÅ s‚ÇÇ t‚ÇÇ e‚Çõ e‚Çú
--     apply Quotient.sound
--     apply SubEquiv.cons <;> assumption

def Eq.ap_apply_natural {Œ≤ : Œ± ‚Üí Sort _} {Œ≥ : (x : Œ±) ‚Üí (y : Œ≤ x) ‚Üí Sort _}
   {a a' : Œ±} (h : a = a') (f : (x : Œ≤ a) ‚Üí Œ≥ a' (h ‚ñ∏ x)) :
  ‚àÄ b : Œ≤ a, f (h ‚ñ∏ b) = h ‚ñ∏ f b := by
  intro x
  cases h
  simp

def SynCat (œÉ : Sig) : Category where
  Ob := Ctx œÉ
  Hom Œì Œî := Syn Œì Œî
  id A := Quotient.mk' (Subst.ide A)
  comp := Quotient.lift‚ÇÇ (Œª f g => Quotient.mk' (f.comp g)) (by
    intro a‚ÇÅ b‚ÇÅ a‚ÇÇ b‚ÇÇ r‚ÇÅ r‚ÇÇ
    apply Quotient.sound
    exact SubEquiv.comp_congr r‚ÇÅ r‚ÇÇ
    )
  id_comp := Quotient.ind (Œª s => Quotient.sound (SubEquiv.ofEq (Subst.ide_comp s)))
  comp_id := Quotient.ind (Œª s => Quotient.sound (SubEquiv.ofEq (Subst.comp_ide s)))
  comp_assoc :=
    Quotient.ind Œª f =>
    Quotient.ind Œª g => 
    Quotient.ind Œª h => 
    Quotient.sound (SubEquiv.ofEq (Subst.comp_assoc f g h))

theorem Subst.proj‚ÇÅ_pair {f : Subst X Œì} {g : Subst X Œî} : Subst.proj‚ÇÅ.comp (Subst.pair f g) = f := by
  induction Œî with
  | nil => cases g; simp [(¬∑++¬∑), Append.append, concat, proj‚ÇÅ, pair]; rw [ide_comp]
  | cons Œî œÑ ih =>
    cases g; simp [(¬∑++¬∑), Append.append, concat, proj‚ÇÅ, pair]
    simp [drop_comp, head, ih]

theorem Subst.proj‚ÇÇ_pair {f : Subst X Œì} {g : Subst X Œî} : Subst.proj‚ÇÇ.comp (Subst.pair f g) = g := by
  induction Œî with
  | nil => cases g; rfl
  | cons Œî œÑ ih =>
    cases g; simp [(¬∑++¬∑), Append.append, concat, proj‚ÇÇ, pair]
    simp [keep, comp, Tm.subst, Var.subst, head, drop_comp, ih]

theorem Subst.pair_unique {f : Subst X Œì} {g : Subst X Œî} {fg : Subst X (Œì ++ Œî)} :
  proj‚ÇÅ.comp fg = f ‚Üí proj‚ÇÇ.comp fg = g ‚Üí Subst.pair f g = fg := by
  intro h‚ÇÅ h‚ÇÇ
  induction Œî with
  | nil => cases g; simp [(¬∑++¬∑), Append.append, concat, comp, proj‚ÇÅ, ide_comp] at h‚ÇÅ; exact h‚ÇÅ.symm
  | cons Œî œÑ ih =>
    cases fg; cases g;
    simp [keep, comp, drop_comp, head, Tm.subst, Var.subst] at h‚ÇÅ h‚ÇÇ
    simp
    have ‚ü®h‚ÇÇ‚ÇÅ, h‚ÇÇ‚ÇÇ‚ü© := h‚ÇÇ
    constructor
    ¬∑ apply ih
      rw [h‚ÇÅ]
      rw [h‚ÇÇ‚ÇÅ]
    ¬∑ rw [h‚ÇÇ‚ÇÇ]
      

theorem TmEquiv.lam'_congr {s s' : (X ++ Œì) ‚ä¢ œÑ} :
  s ‚âà s' ‚Üí (Subst.lam' s) ‚âà (Subst.lam' s') := by
  revert œÑ
  induction Œì with
  | nil => intro œÑ s s' e; exact e
  | cons Œì œÑ ih => intro œÑ s s' e; exact ih (TmEquiv.lam_congr e)
    
theorem SubEquiv.lam_congr {s s' : Subst (X ++ Œì) Œî} :
  s ‚âà s' ‚Üí s.lam ‚âà s'.lam := by
  intro e
  induction e with
  | nil => apply Setoid.refl
  | cons e‚Çõ e‚Çú ih => simp [Subst.lam]; apply SubEquiv.cons ih (TmEquiv.lam'_congr e‚Çú)

@[simp]
theorem pow_nil : Œî ^ Œµ = Œî := by
  induction Œî with
  | nil => rfl
  | cons Œî œÑ ih => simp [Subst.arr, ih]

@[simp]
theorem pair_drop {f : Subst X Œì} {g : Subst X Œî}: (f.drop œÑ).pair (g.drop œÑ) = (f.pair g).drop œÑ := by
  induction g with
  | nil => rfl
  | cons g t ih => simp [Subst.drop, ih]

theorem TmEquiv.app_lam' {f : (X ++ Œì) ‚ä¢ Œî} {x : Subst X Œì} :
  Subst.app (Subst.lam' f) x ‚âà f.subst ((Subst.ide _).pair x) := by
  revert Œî
  induction x with
  | nil => intro Œî f; simp; apply TmEquiv.refl
  | cons xs x ih =>
      intro Œî f
      simp [Subst.lam', Subst.app, Subst.apps, Subst.comp]
      apply TmEquiv.trans
      ¬∑ apply TmEquiv.app_congr
        ¬∑ apply ih
        ¬∑ apply TmEquiv.refl
      ¬∑ apply TmEquiv.trans
        ¬∑ apply TmEquiv.arr_Œ≤
        ¬∑ rw [‚ÜêTm.subst_comp]
          simp [Subst.keep, Subst.comp, Subst.drop_comp, Subst.head, Tm.subst, Var.subst,
                Subst.comp_ide]
          apply TmEquiv.refl

theorem SubEquiv.apps_lam {f : Subst (X ++ Œì) Œî} {x : Subst X Œì} :
  Subst.apps (Subst.lam f) x ‚âà f.comp ((Subst.ide _).pair x) := by
  induction f with
  | nil => apply Setoid.refl
  | cons fs f ih =>
      simp [Subst.lam, Subst.apps, Subst.comp]
      constructor
      ¬∑ assumption
      ¬∑ apply TmEquiv.app_lam'

theorem Subst.app_subst {f : X ‚ä¢ arr Œì œÑ} {x : Subst X Œì} {g : Subst Y X} :
  (Subst.app f x).subst g = Subst.app (f.subst g) (x.comp g) := by
  revert œÑ
  induction x with
  | nil => intro œÑ f; rfl
  | cons xs x ih =>
    intro œÑ f
    simp [Subst.arr, Subst.app, Subst.comp, Tm.subst]
    apply ih

theorem Subst.apps_comp {f : Subst X (Œî^Œì)} {x : Subst X Œì} {g : Subst Y X} :
  (Subst.apps f x).comp g = Subst.apps (f.comp g) (x.comp g) := by
  induction Œî with
  | nil => rfl
  | cons Œî œÑ ih =>
    cases f with | cons fs f =>
    simp [Subst.apps, Subst.comp]
    constructor
    ¬∑ apply ih
    ¬∑ apply Subst.app_subst

theorem Subst.lam'_subst {f : (X ++ Œì) ‚ä¢ œÑ} {g : Subst Y X} :
  (Subst.lam' f).subst g = lam' (f.subst (g.par (Subst.ide _))) := by
  revert œÑ
  induction Œì with
  | nil => intro œÑ f; simp [lam', par, pair, comp_ide]
  | cons Œì œÖ ih =>
    intro œÑ f
    simp [Subst.lam', Subst.comp, Subst.par, ih, Tm.subst]
    apply congrArg lam'
    apply congrArg Tm.lam
    simp [keep,ide_comp, ofRenaming_drop, drop_comp, head, comp_drop, Var.subst]
    rw [‚Üêide, ide_comp]

theorem Subst.lam_comp {f : Subst (X ++ Œì) Œî} {g : Subst Y X} :
  (Subst.lam f).comp g = lam (f.comp (g.par (Subst.ide _))) := by
  induction f with
  | nil => rfl
  | cons fs f ih =>
    simp [Subst.apps, Subst.comp, Subst.lam]
    apply congrArg‚ÇÇ cons
    ¬∑ apply ih
    ¬∑ simp [Subst.lam'_subst]

theorem Subst.par_comp_pair : (Subst.par a b).comp (Subst.pair c d) =
                              Subst.pair (a.comp c) (b.comp d) := by
  simp [Subst.par]
  induction b with
  | nil => simp [Subst.comp, Subst.comp_assoc, proj‚ÇÅ_pair]
  | cons b‚Çõ b‚Çú ih =>
    simp [comp, pair]
    constructor
    ¬∑ apply ih
    ¬∑ rw [‚ÜêTm.subst_comp, proj‚ÇÇ_pair]

theorem Subst.pair_proj‚ÇÅ_proj‚ÇÇ : Subst.pair (Subst.proj‚ÇÅ (Œì := Œì) (Œî := Œî)) Subst.proj‚ÇÇ =
  Subst.ide (Œì ++ Œî) := (Subst.pair_unique (Subst.comp_ide _)
                                           (Subst.comp_ide _))

theorem SubEquiv.eval_lam {s : Subst (X ++ Œì) Œî} :
  Subst.eval.comp (s.lam.par (Subst.ide Œì)) ‚âà s := by
  simp [Subst.eval, Subst.par]
  rw [Subst.apps_comp, Subst.proj‚ÇÅ_pair, Subst.proj‚ÇÇ_pair]
  rw [Subst.ide_comp, Subst.lam_comp]
  induction s with
  | nil => apply Setoid.refl
  | cons s t ih =>
      simp [Subst.lam, Subst.comp, Subst.apps]
      constructor
      ¬∑ apply ih
      ¬∑ apply TmEquiv.trans
        apply TmEquiv.app_lam'
        rw [‚ÜêTm.subst_comp, Subst.par_comp_pair, Subst.comp_ide, Subst.ide_comp,
            Subst.pair_proj‚ÇÅ_proj‚ÇÇ, Tm.subst_ide]
        apply TmEquiv.refl
        
instance : Cartesian (SynCat œÉ) where
  hasTerminal := {
    apex := Œµ
    universal := Quotient.mk' .nil
    unique := Quotient.ind Œª .nil => Quotient.sound (SubEquiv.ofEq rfl)  
  }
  hasProducts (Œì Œî : Ctx œÉ) := {
    apex := Œì ++ Œî
    is_product := {
      œÄ‚ÇÅ := Quotient.mk' Subst.proj‚ÇÅ
      œÄ‚ÇÇ := Quotient.mk' Subst.proj‚ÇÇ
      universal := Œª {X} fq gq =>
        Quotient.liftOn‚ÇÇ fq gq (Œª f g => Quotient.mk' $ Subst.pair f g) $ by
              intro s‚ÇÅ s‚ÇÇ s‚ÇÅ' s‚ÇÇ' e‚ÇÅ e‚ÇÇ
              apply Quotient.sound
              apply SubEquiv.pair_congr e‚ÇÅ e‚ÇÇ
      universal_prop := Œª {X} fq gq =>
        by
          simp [Category.compose, SynCat]
          have ‚ü®f, h_f‚ü© := Quotient.exists_rep fq
          have ‚ü®g, h_g‚ü© := Quotient.exists_rep gq
          rw [‚Üêh_f, ‚Üêh_g]
          constructor <;> apply Quotient.sound
          ¬∑ apply SubEquiv.ofEq Subst.proj‚ÇÅ_pair
          ¬∑ apply SubEquiv.ofEq Subst.proj‚ÇÇ_pair
      unique := by
        intro X fq gq fgq h‚ÇÅ h‚ÇÇ
        have ‚ü®f, h_f‚ü© := Quotient.exists_rep fq
        have ‚ü®g, h_g‚ü© := Quotient.exists_rep gq
        have ‚ü®fg, h_fg‚ü© := Quotient.exists_rep fgq
        rw [‚Üêh_f, ‚Üêh_g, ‚Üêh_fg]
        apply Quotient.sound
        rw [‚Üêh_f, ‚Üêh_fg] at h‚ÇÅ
        rw [‚Üêh_g, ‚Üêh_fg] at h‚ÇÇ
        simp [Category.compose, SynCat] at h‚ÇÅ h‚ÇÇ
        let h‚ÇÅ' := Quotient.exact h‚ÇÅ
        let h‚ÇÇ' := Quotient.exact h‚ÇÇ
        let p := SubEquiv.pair_congr h‚ÇÅ' h‚ÇÇ'
        apply Setoid.trans p
        apply SubEquiv.ofEq
        apply Subst.pair_unique <;> rfl
    }
  }

theorem TmEquiv.big_arr_Œ∑ {f : X ‚ä¢ Subst.arr Œì œÑ}:
  f ‚âà Subst.lam' (Subst.app (f.subst Subst.proj‚ÇÅ) (Subst.proj‚ÇÇ)) := by
  revert œÑ
  induction Œì with
  | nil => intro œÑ f
           simp [Subst.lam', Subst.app]
           apply TmEquiv.refl
  | cons Œì œÖ ih =>
    intro œÑ f
    simp [Subst.lam', Subst.app]
    apply TmEquiv.trans
    ¬∑ apply ih
    ¬∑ rw [‚ÜêTm.subst_weaken, Subst.weaken_drop, Subst.weaken_ide]
      simp [Subst.arr] at f
      apply lam'_congr (X := X) (Œì := Œì)
      apply TmEquiv.trans
      apply TmEquiv.arr_Œ∑
      simp
      rw [‚ÜêTm.subst_weaken, Subst.weaken_drop, Subst.weaken_ide]
      apply TmEquiv.lam_congr
      simp [Subst.app, Subst.keep]
      rw [‚ÜêTm.subst_weaken, Subst.weaken_drop, Subst.weaken_ide,
         ‚ÜêTm.subst_renaming, Subst.app_subst, ‚ÜêTm.subst_comp,
         ‚ÜêSubst.weaken_eq_comp_ofRenaming, Subst.weaken_drop,
         Subst.weaken_ide, ‚ÜêSubst.weaken_eq_comp_ofRenaming,
         Subst.weaken_drop, Subst.weaken_ide]
      apply TmEquiv.refl

theorem TmEquiv.lam'_unique {f : (X ++ Œì) ‚ä¢ œÑ} {f' : X ‚ä¢ Subst.arr Œì œÑ}
  (h : f ‚âà Subst.app (Tm.subst f' Subst.proj‚ÇÅ) Subst.proj‚ÇÇ) :
  f' ‚âà Subst.lam' f := by
  apply TmEquiv.trans
  apply TmEquiv.big_arr_Œ∑
  apply TmEquiv.lam'_congr
  apply Setoid.symm
  assumption

theorem SubEquiv.lam_unique {f : Subst (X ++ Œì) Œî} {f' : Subst X (Œî^Œì)}
  (h : f ‚âà Subst.apps (f'.comp Subst.proj‚ÇÅ) Subst.proj‚ÇÇ) :
  f' ‚âà Subst.lam f := by
  induction Œî with
  | nil => cases f'; apply SubEquiv.nil
  | cons Œî œÑ ih =>
    cases f with | cons fs f =>
    cases f' with | cons f's f' =>
    cases h with | cons h‚Çõ h‚Çú =>
    simp [Subst.lam]
    apply SubEquiv.cons
    ¬∑ apply ih
      exact h‚Çõ
    ¬∑ apply TmEquiv.lam'_unique h‚Çú

theorem SubEquiv.app_congr {s‚ÇÅ s‚ÇÅ' : Œì ‚ä¢ Subst.arr Œî œÑ} {s‚ÇÇ s‚ÇÇ' : Subst Œì Œî} : s‚ÇÅ ‚âà s‚ÇÅ' ‚Üí s‚ÇÇ ‚âà s‚ÇÇ' ‚Üí Subst.app s‚ÇÅ s‚ÇÇ ‚âà Subst.app s‚ÇÅ' s‚ÇÇ' := by
  intro e‚ÇÅ e‚ÇÇ
  revert œÑ
  induction e‚ÇÇ with
  | nil => intro œÑ s‚ÇÅ s‚ÇÇ e‚ÇÅ; exact e‚ÇÅ
  | cons _ e‚ÇÇ‚Çú ih =>
    intro œÑ s‚ÇÅ s‚ÇÇ e‚ÇÅ
    simp [Subst.app]
    apply TmEquiv.app_congr
    ¬∑ apply ih e‚ÇÅ
    ¬∑ assumption
      
theorem SubEquiv.apps_congr {s‚ÇÅ s‚ÇÅ' : Subst Œì (Subst.exp Œî Œï)} {s‚ÇÇ s‚ÇÇ' : Subst Œì Œî} : s‚ÇÅ ‚âà s‚ÇÅ' ‚Üí s‚ÇÇ ‚âà s‚ÇÇ' ‚Üí Subst.apps s‚ÇÅ s‚ÇÇ ‚âà Subst.apps s‚ÇÅ' s‚ÇÇ' := by
  intro e‚ÇÅ e‚ÇÇ
  induction Œï with
  | nil => apply SubEquiv.nil; 
  | cons Œï œÑ ih =>
    cases e‚ÇÅ with | cons e‚ÇÅ‚Çõ e‚ÇÅ‚Çú =>
    apply SubEquiv.cons
    ¬∑ apply ih e‚ÇÅ‚Çõ
    ¬∑ apply SubEquiv.app_congr
      ¬∑ apply e‚ÇÅ‚Çú
      ¬∑ apply e‚ÇÇ

instance : CartesianClosed (SynCat œÉ) where
  closed Œì Œî := {
    exp := Subst.exp Œì Œî
    is_exponential := {
      lam := Quotient.lift (Œª f => Quotient.mk' (Subst.lam f)) Œª a b e =>
        Quotient.sound (SubEquiv.lam_congr e)
      eval := Quotient.mk' Subst.eval
      eval_lam := by
        intro X
        apply Quotient.ind
        intro f
        apply Quotient.sound
        apply SubEquiv.eval_lam
      unique := by
        intro X
        apply Quotient.ind‚ÇÇ
        intro f f'
        intro h
        have h := Quotient.exact h
        apply Quotient.sound
        apply SubEquiv.lam_unique
        simp [Subst.eval, Subst.apps_comp, Subst.proj‚ÇÅ_pair, Subst.proj‚ÇÇ_pair, Subst.ide_comp] at h
        assumption
    }
  }

def interpSubst_append.pair :
  ‚àÄ {Œì Œî}, X ‚ü∂ ‚ü¶Œì‚üßCtx[Str] ‚Üí X ‚ü∂ ‚ü¶Œî‚üßCtx[Str] ‚Üí X ‚ü∂ ‚ü¶Œì ++ Œî‚üßCtx[Str]
| _, Œµ,    f, _ => f
| _, _,,_, f, g => Cartesian.pair (pair f (proj‚ÇÅ ‚äö g)) (proj‚ÇÇ ‚äö g)

def interpSubst_append : is_product ùíû ‚ü¶Œì‚üßCtx[Str] ‚ü¶Œî‚üßCtx[Str] ‚ü¶Œì ++ Œî‚üßCtx[Str] where
  œÄ‚ÇÅ := ‚ü¶Subst.proj‚ÇÅ‚üßSub[Str]
  œÄ‚ÇÇ := ‚ü¶Subst.proj‚ÇÇ‚üßSub[Str]
  universal f g := interpSubst_append.pair _ f g
  universal_prop f g := by
    induction Œî with
    | nil => simp [interpSubst_append.pair]
             apply Eq.trans
             apply bang_unique
             apply Eq.symm
             apply bang_unique
    | cons Œî œÑ ih => simp [interpSubst_append.pair, Subst.keep, interpSubst_drop,
                           interpSubst]
                     let ‚ü®ih‚ÇÅ, ih‚ÇÇ‚ü© := ih (proj‚ÇÅ ‚äö g)
                     constructor
                     ¬∑ assumption
                     ¬∑ simp [interpTm, interpVar]
                       rw [‚Üêpair_comp, Category.assoc, proj‚ÇÅ_pair, proj‚ÇÇ_pair]
                       apply pair_unique
                       ¬∑ assumption
                       ¬∑ rfl
  unique {X} := by
    revert Œì
    induction Œî with
    | nil =>
      intro Œì f g fg h‚ÇÅ _
      simp [interpSubst_append.pair]
      simp [interpSubst] at h‚ÇÅ
      apply h‚ÇÅ
    | cons Œî œÑ ih =>
      intro Œì f g fg h‚ÇÅ h‚ÇÇ
      simp [interpSubst_append.pair]
      simp [interpSubst_drop, interpSubst, interpTm, interpVar, ‚Üêpair_comp] at h‚ÇÅ h‚ÇÇ
      apply pair_unique
      ¬∑ let h‚ÇÇ‚ÇÅ := congrArg (proj‚ÇÅ ‚äö ¬∑) h‚ÇÇ
        simp at h‚ÇÇ‚ÇÅ
        let p := ih f (proj‚ÇÅ ‚äö g) (proj‚ÇÅ ‚äö fg) h‚ÇÅ h‚ÇÇ‚ÇÅ
        simp at p
        rw [p]
      ¬∑ let h‚ÇÇ‚ÇÇ := congrArg (proj‚ÇÇ ‚äö ¬∑) h‚ÇÇ
        simp at h‚ÇÇ‚ÇÇ
        assumption

def prod.assoc [CartesianClosed ùíû] (A B C : ùíû) : Iso ùíû (A √ó' B √ó' C) (A √ó' (B √ó' C)) where
  to := pair (proj‚ÇÅ ‚äö proj‚ÇÅ) (pair (proj‚ÇÇ ‚äö proj‚ÇÅ) proj‚ÇÇ)
  to_isIso := {
    inv := pair (pair proj‚ÇÅ (proj‚ÇÅ ‚äö proj‚ÇÇ)) (proj‚ÇÇ ‚äö proj‚ÇÇ)
    leftInv := by
      simp [‚Üêpair_comp]
      rw [Category.id_compose (B := A √ó' B) proj‚ÇÅ]
      simp
    rightInv := by
      simp [‚Üêpair_comp]
      rw [Category.id_compose (B := B √ó' C) proj‚ÇÇ]
      simp
  }
def interpSubst_exp.lam' :
  ‚àÄ {Œì œÑ}, X √ó' ‚ü¶Œì‚üßCtx[Str] ‚ü∂ ‚ü¶œÑ‚üßTy[Str] ‚Üí X ‚ü∂ ‚ü¶Subst.arr Œì œÑ‚üßTy[Str]
| Œµ,    _, f => f ‚äö pair (ùüô _) bang 
| Œì,,_, _, f => interpSubst_exp.lam' (Œì := Œì)
  (lam (f ‚äö (prod.assoc _ _ _).to))

def interpSubst_exp.lam :
  ‚àÄ {Œì Œî}, X √ó' ‚ü¶Œì‚üßCtx[Str] ‚ü∂ ‚ü¶Œî‚üßCtx[Str] ‚Üí X ‚ü∂ ‚ü¶Subst.exp Œì Œî‚üßCtx[Str]
| _, Œµ,    _ => bang
| _, _,,_, f => pair (interpSubst_exp.lam (proj‚ÇÅ ‚äö f))
                     (interpSubst_exp.lam' Str (proj‚ÇÇ ‚äö f))

def interpSubst_exp.eval' :
  ‚àÄ {Œì œÑ}, ‚ü¶Subst.arr Œì œÑ‚üßTy[Str] √ó' ‚ü¶Œì‚üßCtx[Str] ‚ü∂ ‚ü¶œÑ‚üßTy[Str]
| Œµ,    _ => proj‚ÇÅ
| Œì,,œÖ, œÑ => let p := eval' (Œì := Œì) (œÑ := œÖ.arr œÑ)
             eval ‚äö pair (p ‚äö prod.map (ùüô _) proj‚ÇÅ) (proj‚ÇÇ ‚äö proj‚ÇÇ)


theorem interpSubst_exp.eval'_lam' :
  ‚àÄ {X Œì œÑ} (f : X √ó' ‚ü¶Œì‚üßCtx[Str] ‚ü∂ ‚ü¶œÑ‚üßTy[Str]),
    eval' Str ‚äö prod.map (lam' Str f) (ùüô _) = f := by
    intro X Œì
    induction Œì with
    | nil => intro œÑ f
             simp [eval', lam', prod.map]
             rw [‚ÜêCategory.compose_id f, Category.assoc]
             apply congrArg (f ‚äö ¬∑)
             simp [‚Üêpair_comp]
             apply pair_unique <;> simp
             apply (bang_unique _).trans (bang_unique _).symm
    | cons Œì œÑ ih => intro œÖ f
                     simp [eval', lam', prod.map]
                     simp [‚Üêpair_comp, Category.assoc]
                     have p := ih (œÑ := œÑ.arr œÖ)
                                 (CartesianClosed.lam (f ‚äö (prod.assoc _ _ _).to))
                     rw [‚Üêprod.map, ‚ÜêCategory.id_compose proj‚ÇÅ,
                         ‚ÜêCategory.compose_id (lam' _ _),
                         prod.map_comp, ‚ÜêCategory.assoc, p]
                     simp [prod.map, prod.assoc]
                     rw [‚Üêprod.lam_of_comp, Category.assoc, ‚Üêpair_comp]
                     simp [prod.map, ‚ÜêCategory.assoc]
                     rw [‚Üêpair_comp, Category.assoc, proj‚ÇÅ_pair, proj‚ÇÇ_pair,
                         ‚ÜêCategory.assoc, proj‚ÇÇ_pair]
                     rw [eval_pair_lam]
                     simp [Category.assoc, ‚Üêpair_comp]
                     rw [Category.id_compose (B := (‚ü¶Œì‚üßCtx[Str] √ó' interpTy Str.types œÑ))
                         proj‚ÇÇ, pair_proj‚ÇÅ_proj‚ÇÇ,
                         Category.compose_id (A := (X √ó' (‚ü¶Œì‚üßCtx[Str] √ó' interpTy Str.types œÑ))) f]

theorem lam_of_eval [CartesianClosed ùíû] {A B : ùíû}:
  lam (eval) = ùüô (exp A B) := by
  apply Eq.symm
  apply lam_unique
  simp [prod.map_id]


theorem interpSubst_exp.unique' :
  ‚àÄ {X Œì œÑ} (f : X √ó' ‚ü¶Œì‚üßCtx[Str] ‚ü∂ ‚ü¶œÑ‚üßTy[Str]) (f' : X ‚ü∂ ‚ü¶Subst.arr Œì œÑ‚üßTy[Str]),
    eval' Str ‚äö (prod.map f' (ùüô ‚ü¶Œì‚üßCtx[Str])) = f ‚Üí f' = lam' Str f := by
    intro X Œì
    induction Œì with
    | nil => intro œÑ f f' h
             simp [eval', prod.map] at h
             simp [lam', ‚Üêh]
    | cons Œì œÑ ih =>
      intro œÑ f f' h
      simp [eval', prod.map, ‚Üêpair_comp] at h
      simp [lam']
      apply ih
      simp [‚Üêh, prod.assoc]
      simp [‚Üêpair_comp]
      rw [‚ÜêCategory.assoc, pair_comp, ‚ÜêCategory.assoc,
          ‚ÜêCategory.id_compose proj‚ÇÇ, ‚Üêprod.map,
          ‚ÜêCategory.id_compose proj‚ÇÇ, ‚Üêprod.map,
          prod.lam_of_comp, lam_of_eval]
      simp

def interpSubst_exp.eval :
  ‚àÄ {Œì Œî}, ‚ü¶Subst.exp Œì Œî‚üßCtx[Str] √ó' ‚ü¶Œì‚üßCtx[Str] ‚ü∂ ‚ü¶Œî‚üßCtx[Str]
| _, Œµ    => bang
| Œì, _,,_ => pair (interpSubst_exp.eval (Œì := Œì) ‚äö (prod.map proj‚ÇÅ (ùüô _)))
                  (interpSubst_exp.eval' (Œì := Œì) Str ‚äö prod.map proj‚ÇÇ (ùüô _))

def interpSubst_exp : is_exponential ùíû ‚ü¶Œì‚üßCtx[Str] ‚ü¶Œî‚üßCtx[Str] ‚ü¶Subst.exp Œì Œî‚üßCtx[Str] where
  lam := interpSubst_exp.lam Str
  eval := interpSubst_exp.eval Str
  eval_lam := by
    revert Œì
    induction Œî with
    | nil => intro Œì X f
             apply Eq.trans
             apply bang_unique
             apply Eq.symm
             apply bang_unique
    | cons Œî œÑ ih => intro Œì X f
                     simp [interpSubst_exp.eval, interpSubst_exp.eval,
                           interpSubst_exp.lam]
                     rw [‚Üêpair_comp]
                     apply pair_unique
                     ¬∑ simp
                       rw [‚Üêprod.map_comp_fst, proj‚ÇÅ_pair]
                       apply ih
                     ¬∑ simp
                       rw [‚Üêprod.map_comp_fst, proj‚ÇÇ_pair]
                       rw [interpSubst_exp.eval'_lam']
  unique := by
    intro X
    induction Œî with
    | nil => intro f f' _
             apply (bang_unique _)
    | cons Œî œÑ ih =>
      simp [interpSubst_exp.eval, interpSubst_exp.lam]
      intro f f' h
      apply Eq.symm
      apply pair_unique
      ¬∑ apply Eq.symm
        apply ih
        apply Eq.trans
        apply congrArg (proj‚ÇÅ ‚äö ¬∑) h
        rw [‚ÜêCategory.assoc, proj‚ÇÅ_pair, Category.assoc, ‚Üêprod.map_comp_fst]
      ¬∑ rw [‚Üêpair_comp, Category.assoc, Category.assoc,
            ‚Üêprod.map_comp_fst, ‚Üêprod.map_comp_fst] at h
        have h' := congrArg (proj‚ÇÇ ‚äö ¬∑) h
        simp at h'
        have p := interpSubst_exp.unique' Str (proj‚ÇÇ ‚äö f) (proj‚ÇÇ ‚äö f') h'.symm
        exact p.symm

@[simp]
theorem SynCat.proj‚ÇÅ_def : proj‚ÇÅ (ùíû := SynCat œÉ) (A := Œì) (B := Œî) =
  Quotient.mk' Subst.proj‚ÇÅ := rfl

@[simp]
theorem SynCat.proj‚ÇÇ_def : proj‚ÇÇ (ùíû := SynCat œÉ) (A := Œì) (B := Œî) =
  Quotient.mk' Subst.proj‚ÇÇ := rfl

theorem interpSubst_app :
  ‚ü¶Subst.app (Œì := Œì) (Œî := Œî) (œÑ := œÑ) f x‚üßTm[Str] =
    interpSubst_exp.eval' Str ‚äö pair (‚ü¶f‚üßTm[Str]) (‚ü¶x‚üßSub[Str]) := by
  revert œÑ
  induction x with
  | nil => simp [Subst.app, interpSubst_exp.eval']
  | cons xs x ih =>
    simp [Subst.app, interpTm, Subst.arr, interpSubst_exp.eval']
    intro œÑ f
    apply congrArg
    rw [‚Üêpair_comp, pair_ext]
    constructor
    ¬∑ rw [ih, Category.assoc, prod.map_comp_pair]
      simp [interpSubst]
    ¬∑ simp [interpSubst]

theorem interpSubst_apps :
  ‚ü¶Subst.apps (Œì := Œì) (Œî := Œî) (Œï := Œï) f x‚üßSub[Str] =
    interpSubst_exp.eval Str ‚äö pair (‚ü¶f‚üßSub[Str]) (‚ü¶x‚üßSub[Str]) := by
  induction Œï with
  | nil => apply (bang_unique _).symm
  | cons Œî œÑ ih =>
    cases f with | cons fs f =>
    simp [Subst.apps, interpSubst]
    simp [interpSubst_exp.eval]
    apply pair_unique
    ¬∑ rw [‚Üêpair_comp, Category.assoc, prod.map_comp_pair,
          Category.assoc, prod.map_comp_pair, proj‚ÇÅ_pair, proj‚ÇÅ_pair,
          ih, Category.id_compose]
    ¬∑ rw [interpSubst_app, ‚Üêpair_comp, proj‚ÇÇ_pair,
          Category.assoc, prod.map_comp_pair, proj‚ÇÇ_pair,
          Category.id_compose]

theorem interpSubst_proj‚ÇÅ :
  ‚ü¶Subst.proj‚ÇÅ (Œì := Œì) (Œî := Œî)‚üßSub[Str] = (interpSubst_append Str).œÄ‚ÇÅ := by
  simp [interpSubst_append]

theorem interpSubst_proj‚ÇÇ :
  ‚ü¶Subst.proj‚ÇÇ (Œì := Œì) (Œî := Œî)‚üßSub[Str] = (interpSubst_append Str).œÄ‚ÇÇ := by
  simp [interpSubst_append]

theorem interpSubst_eval :
  ‚ü¶Subst.eval (Œì := Œì) (Œî := Œî)‚üßSub[Str] ‚äö interpSubst_append.pair Str proj‚ÇÅ proj‚ÇÇ =
    interpSubst_exp.eval Str := by
  rw [Subst.eval, interpSubst_apps, interpSubst_proj‚ÇÅ, interpSubst_proj‚ÇÇ]
  simp [interpSubst]
  rw [‚ÜêCategory.compose_id (interpSubst_exp.eval Str), Category.assoc]
  apply congrArg
  simp
  let h := ((interpSubst_append Str (Œì := Subst.exp Œì Œî) (Œî := Œì)).universal_prop proj‚ÇÅ proj‚ÇÇ)
  simp [interpSubst_append] at h
  simp [interpSubst_append]
  rw [‚Üêpair_comp]
  apply pair_unique
  ¬∑ rw [Category.compose_id proj‚ÇÅ (A := (‚ü¶Subst.exp Œì Œî‚üßCtx[Str] √ó' ‚ü¶Œì‚üßCtx[Str])), h.1]
  ¬∑ rw [Category.compose_id proj‚ÇÇ (A := (‚ü¶Subst.exp Œì Œî‚üßCtx[Str] √ó' ‚ü¶Œì‚üßCtx[Str])), h.2]

def SynCat.prod_ty Œì œÑ œÖ : Iso (SynCat œÉ) (Œì ,, Ty.prod œÑ œÖ) (Œì ,, œÑ ,, œÖ) where
  to := Quotient.mk' (.cons (.cons (Subst.proj‚ÇÅ (Œî := Œµ ,, œÑ.prod œÖ))
                                   (.fst (.var .zero)))
                                   (.snd (.var .zero)))
  to_isIso := {
    inv := Quotient.mk' (.cons (Subst.proj‚ÇÅ (Œî := Œµ ,, œÑ ,, œÖ))
                               (.pair (.var (.succ .zero))
                                      (.var .zero)))
    leftInv := by
      apply Quotient.sound
      apply SubEquiv.cons
      ¬∑ simp [Subst.drop_comp, Subst.head, Subst.ide_comp, Subst.ofRenaming_drop]
        apply SubEquiv.refl
      ¬∑ apply TmEquiv.prod_Œ∑.symm
    rightInv := by
      apply Quotient.sound
      apply SubEquiv.cons
      ¬∑ apply SubEquiv.cons
        ¬∑ simp [Subst.drop_comp, Subst.ide_comp, Subst.head, Subst.ofRenaming_drop]
          apply SubEquiv.refl
        ¬∑ apply TmEquiv.prod_Œ≤‚ÇÅ
      ¬∑ apply TmEquiv.prod_Œ≤‚ÇÇ
  }

def SynCat.unit_ty Œì : Iso (SynCat œÉ) (Œì ,, Ty.unit) Œì where
  to := Quotient.mk' ((Subst.ide Œì).drop .unit)
  to_isIso := {
    inv := Quotient.mk' (.cons (Subst.ide Œì) .unit)
    leftInv := by
      apply Quotient.sound
      simp [Subst.comp, Subst.ide_comp, Tm.rename]
      apply SubEquiv.cons
      ¬∑ rw [Subst.ofRenaming_drop]; apply SubEquiv.refl
      ¬∑ apply TmEquiv.unit_Œ∑.symm
    rightInv := by
      apply Quotient.sound
      simp [Subst.drop_comp, Subst.ide_comp, Subst.head]
      apply SubEquiv.refl
  }

def SynCat_equiv_Struct.to (Str : Struct œÉ ùíû) : CCFunctor (SynCat œÉ) ùíû where
  obj Œì := ‚ü¶Œì‚üßCtx[Str]
  map := Quotient.lift (‚ü¶¬∑‚üßSub[Str]) Œª _ _ => interpSubst_preserves_equiv Str
  map_id {Œì} := by simp [Category.identity, SynCat,
                         Quotient.lift, Quotient.mk', Quotient.mk] 
  map_comp {B} {C} {A} := Quotient.ind‚ÇÇ Œª f g => interpSubst_comp Str
  preserve_terminal := {
    inv := bang 
    leftInv := by
      apply Eq.trans
      apply bang_unique
      apply Eq.symm
      apply bang_unique
    rightInv := by
      apply Eq.trans
      apply bang_unique
      apply Eq.symm
      apply bang_unique
  }
  preserve_products Œì Œî := {
    inv := interpSubst_append.pair _ proj‚ÇÅ proj‚ÇÇ
    leftInv := is_product_unique.inv (interpSubst_append Str) _
    rightInv := is_product_unique.inv _  (interpSubst_append Str)
  }
  preserve_exponential (Œì : Ctx œÉ) Œî := {
    inv := is_exponential_unique.to (closed ‚ü¶Œì‚üßCtx[Str] ‚ü¶Œî‚üßCtx[Str]).is_exponential
                                    (interpSubst_exp Str)
    leftInv := by
      let h := is_exponential_unique.inv (interpSubst_exp Str)
                                         (closed ‚ü¶Œì‚üßCtx[Str] ‚ü¶Œî‚üßCtx[Str]).is_exponential
      have p : Quotient.lift (fun x => ‚ü¶x‚üßSub[Str])
          (Œª _ _ => interpSubst_preserves_equiv Str)
            (eval : (SynCat œÉ)[Subst.exp Œì Œî ++ Œì, Œî])
          = ‚ü¶Subst.eval‚üßSub[Str] := by
            simp [Quotient.lift, eval, Quotient.mk, closed, Quotient.mk']
      simp [p]
      apply Eq.trans _ h
      simp [is_exponential_unique.to, interpSubst_exp]
      apply congrArg
      apply Eq.symm
      apply lam_unique
      rw [‚Üêlam, eval_lam, interpSubst_eval]
    rightInv := by
      have p : Quotient.lift (fun x => ‚ü¶x‚üßSub[Str])
          (Œª _ _ => interpSubst_preserves_equiv Str)
            (eval : (SynCat œÉ)[Subst.exp Œì Œî ++ Œì, Œî])
          = ‚ü¶Subst.eval‚üßSub[Str] := by
            simp [Quotient.lift, eval, Quotient.mk, closed, Quotient.mk']
      simp [p]
      let h := is_exponential_unique.inv (closed ‚ü¶Œì‚üßCtx[Str] ‚ü¶Œî‚üßCtx[Str]).is_exponential
                                          (interpSubst_exp Str)
      apply Eq.trans _ h
      simp [is_exponential_unique.to, interpSubst_exp]
      rw [‚Üêeval, ‚Üêlam]
      apply congrArg (¬∑ ‚äö interpSubst_exp.lam Str eval)
      apply congrArg
      rw [interpSubst_eval]
  }

def go.lemma_arr [CartesianClosed ùíû] (M : CCFunctor (SynCat œÉ) ùíû)
  (t : Iso ùíû (Functor.obj M.toFunctor (Œµ,,œÑ))
              (interpTy (fun œÑ => Functor.obj M.toFunctor (Œµ,,Ty.base œÑ)) œÑ))
  (u : Iso ùíû (Functor.obj M.toFunctor (Œµ,,œÖ))
              (interpTy (fun œÑ => Functor.obj M.toFunctor (Œµ,,Ty.base œÑ)) œÖ))
  : Iso ùíû (Functor.obj M.toFunctor (Œµ,,Ty.arr œÑ œÖ))
          (interpTy (fun œÑ => Functor.obj M.toFunctor (Œµ,,Ty.base œÑ)) (Ty.arr œÑ œÖ))
  :=
  let Me := lam (M.map eval ‚äö (M.preserve_products (exp (Œµ,,œÑ) (Œµ,,œÖ)) _).inv)
  {
    to := lam (u.to ‚äö eval ‚äö prod.map Me t.to_isIso.inv),
    to_isIso := {
      inv := (M.preserve_exponential (Œµ,,œÑ) (Œµ,,œÖ)).inv ‚äö
              lam (u.to_isIso.inv ‚äö eval ‚äö prod.map (ùüô _) t.to)
      leftInv := by
        simp
        have h := (M.preserve_exponential (Œµ,,œÑ) (Œµ,,œÖ)).leftInv
        simp [exp, SynCat, closed, Subst.exp, Subst.arr] at h
        rw [‚Üêh]
        apply congrArg
        rw [‚Üêprod.lam_of_comp]
        rw [Category.assoc, Category.assoc,
            ‚Üêprod.map_comp, Category.id_compose,
            Category.compose_id,
            prod.map, ‚Üêprod.lam_of_comp,
            eval_pair_lam, ‚ÜêCategory.assoc,
            ‚ÜêCategory.assoc, ‚ÜêCategory.assoc,
            u.to_isIso.leftInv, Category.id_compose,
            prod.map, ‚Üêprod.lam_of_comp,
            eval_pair_lam, Category.assoc,
            Category.assoc, Category.assoc,
            ‚ÜêCategory.assoc (prod.map _ _),
            prod.map_comp_pair]
        simp
        rw [prod.map_comp_pair, ‚Üêpair_comp ]
        simp
        rw [‚ÜêCategory.assoc t.to_isIso.inv, t.to_isIso.leftInv,
            Category.id_compose, pair_proj‚ÇÅ_proj‚ÇÇ, Category.compose_id]
        rfl
      rightInv := by
        simp [interpTy, ‚Üêprod.lam_of_comp]
        apply Eq.symm
        apply lam_unique
        rw [prod.map, ‚Üêprod.lam_of_comp, ‚ÜêCategory.assoc eval, eval_pair_lam,
            prod.map_id, Category.compose_id, Category.assoc, Category.assoc,
            ‚ÜêCategory.assoc (prod.map proj‚ÇÅ _), prod.map_comp_pair,
            prod.map, ‚Üêpair_comp]
        simp
        have h := u.to_isIso.rightInv
        rw [‚ÜêCategory.id_compose (eval (ùíû := ùíû)),
            ‚Üêh, Category.assoc u.to]
        apply congrArg
        rw [‚ÜêCategory.assoc u.to, u.to_isIso.rightInv]
        simp
        rw [‚ÜêCategory.assoc, ‚ÜêCategory.assoc, ‚Üêprod.map]
        have h := (M.preserve_exponential (Œµ,,œÑ) (Œµ,,œÖ)).rightInv
        rw [‚Üêprod.lam_of_comp, ‚Üêlam_of_eval] at h
        have h' := lam_injective _ _ h
        rw [‚ÜêCategory.id_compose t.to_isIso.inv,
            prod.map_comp, ‚ÜêCategory.assoc, h',
            ‚ÜêCategory.id_compose t.to_isIso.inv,
            ‚ÜêCategory.compose_id (lam _), prod.map_comp,
            ‚ÜêCategory.assoc, eval_lam, Category.assoc]
        apply congrArg
        rw [Category.assoc, ‚Üêprod.map_comp_snd,
            t.to_isIso.rightInv, prod.map_id,
            Category.compose_id]
    }
  }

def go.lemma_prod [CartesianClosed ùíû] (M : CCFunctor (SynCat œÉ) ùíû)
  (t : Iso ùíû (Functor.obj M.toFunctor (Œµ,,œÑ))
              (interpTy (fun œÑ => Functor.obj M.toFunctor (Œµ,,Ty.base œÑ)) œÑ))
  (u : Iso ùíû (Functor.obj M.toFunctor (Œµ,,œÖ))
              (interpTy (fun œÑ => Functor.obj M.toFunctor (Œµ,,Ty.base œÑ)) œÖ))
  : Iso ùíû (Functor.obj M.toFunctor (Œµ,,Ty.prod œÑ œÖ))
          (interpTy (fun œÑ => Functor.obj M.toFunctor (Œµ,,Ty.base œÑ)) (Ty.prod œÑ œÖ))
  :=
  {
    to := pair (t.to ‚äö M.map (proj‚ÇÅ (ùíû := SynCat œÉ) (B := Œµ ,, œÖ) ‚äö
                             (SynCat.prod_ty Œµ œÑ œÖ).to))
               (u.to ‚äö M.map (proj‚ÇÇ (ùíû := SynCat œÉ) (B := Œµ ,, œÖ) ‚äö
                             (SynCat.prod_ty Œµ œÑ œÖ).to))
    to_isIso := {
      inv := M.map (SynCat.prod_ty Œµ œÑ œÖ).to_isIso.inv ‚äö
              (M.preserve_products (Œµ,,œÑ) (Œµ,,œÖ)).inv ‚äö
              prod.map t.to_isIso.inv
                      u.to_isIso.inv
      leftInv := by
        rw [Category.assoc, prod.map_comp_pair, M.map_comp, M.map_comp]
        rw [‚ÜêCategory.assoc t.to, ‚ÜêCategory.assoc,
            ‚ÜêCategory.assoc u.to, ‚ÜêCategory.assoc u.to_isIso.inv,
            pair_comp]
        rw [‚ÜêM.map_id, ‚Üê(SynCat.prod_ty Œµ œÑ œÖ).to_isIso.leftInv,
            M.map_comp, ‚ÜêCategory.assoc ]
        apply congrArg (¬∑ ‚äö M.map (SynCat.prod_ty Œµ œÑ œÖ).to)
        rw [‚ÜêCategory.compose_id (M.map (SynCat.prod_ty Œµ œÑ œÖ).to_isIso.inv),
            Category.assoc, Category.assoc]
        apply congrArg
        simp
        have h: (M.preserve_products (Œµ,,œÑ) (Œµ,,œÖ)).inv ‚äö
                  pair (M.map proj‚ÇÅ) (M.map proj‚ÇÇ) = ùüô (M.obj (Œµ,,œÑ,,œÖ)) :=
                  (M.preserve_products (Œµ,,œÑ) (Œµ,,œÖ)).leftInv
        rw [‚Üêh]
        apply congrArg
        rw [‚ÜêCategory.assoc, t.to_isIso.leftInv, Category.id_compose,
            ‚ÜêCategory.assoc, u.to_isIso.leftInv, Category.id_compose,
            pair_ext]
        constructor
        ¬∑ apply congrArg
          apply Quotient.sound
          apply SubEquiv.refl
        ¬∑ apply congrArg
          apply Quotient.sound
          apply SubEquiv.refl
      rightInv := by
        simp [Syn.cons, Syn.nil, Quotient.mk', Quotient.lift, Quotient.lift‚ÇÇ,
              Quotient.mk, Category.compose, SynCat, SynCat.prod_ty]
        repeat rw [‚ÜêCategory.compose]
        simp [Subst.drop_comp, Subst.ide_comp, Subst.head]
        rw [‚Üêpair_comp, Category.assoc t.to,
            ‚ÜêCategory.assoc (M.map _),
            ‚ÜêM.map_comp ]
        simp [Syn.cons, Syn.nil, Quotient.mk', Quotient.lift, Quotient.lift‚ÇÇ,
              Quotient.mk, Category.compose, SynCat, SynCat.prod_ty,
              Subst.comp, Tm.subst, Var.subst]
        repeat rw [‚ÜêCategory.compose]
        rw [‚ÜêCategory.assoc (M.map _) (M.map _),
            ‚ÜêM.map_comp ]
        simp [Syn.cons, Syn.nil, Quotient.mk', Quotient.lift, Quotient.lift‚ÇÇ,
              Quotient.mk, Category.compose, SynCat, SynCat.prod_ty,
              Subst.comp, Tm.subst, Var.subst]
        repeat rw [‚ÜêCategory.compose]
        repeat rw [‚ÜêCategory.assoc]
        rw [pair_comp, pair_comp, Category.assoc (pair _ _)]
        simp [interpTy]
        rw [‚Üêprod.map_id, ‚Üêt.to_isIso.rightInv, ‚Üêu.to_isIso.rightInv,
            ‚ÜêCategory.assoc, prod.map_comp]
        apply congrArg (¬∑ ‚äö prod.map t.to_isIso.inv u.to_isIso.inv)
        rw [‚ÜêCategory.compose_id (prod.map t.to u.to)]
        simp only [prod]
        rw [‚Üê(M.preserve_products (Œµ,,œÑ) (Œµ,,œÖ)).rightInv, ‚ÜêCategory.assoc]
        apply congrArg (¬∑ ‚äö (M.preserve_products (Œµ,,œÑ) (Œµ,,œÖ)).inv)
        rw [prod.map_comp_pair, pair_ext]
        constructor
        ¬∑ apply congrArg
          apply congrArg
          apply Quotient.sound
          apply SubEquiv.cons
          ¬∑ apply SubEquiv.nil
          ¬∑ apply TmEquiv.prod_Œ≤‚ÇÅ
        ¬∑ apply congrArg
          apply congrArg
          apply Quotient.sound
          apply SubEquiv.cons
          ¬∑ apply SubEquiv.nil
          ¬∑ apply TmEquiv.prod_Œ≤‚ÇÇ
    }
  }

def go [CartesianClosed ùíû] (M : CCFunctor (SynCat œÉ) ùíû) : ‚àÄ (œÑ : Ty œÉ.types),
                    Iso ùíû (Functor.obj M.toFunctor (Œµ,,œÑ))
                          (interpTy (fun œÑ => Functor.obj M.toFunctor (Œµ,,Ty.base œÑ)) œÑ)
| .base œÑ => {
  to := ùüô _
  to_isIso := {
    inv := ùüô _
    leftInv := Category.compose_id _
    rightInv := Category.compose_id _
  }
}
| .arr œÑ œÖ => go.lemma_arr M (go M œÑ) (go M œÖ)
| .prod œÑ œÖ => go.lemma_prod M (go M œÑ) (go M œÖ)
| .unit => {
  to := bang
  to_isIso := {
    inv := M.map (SynCat.unit_ty Œµ).to_isIso.inv ‚äö M.preserve_terminal.inv
    leftInv := by
      rw [‚ÜêM.map_id, ‚Üê(SynCat.unit_ty Œµ).to_isIso.leftInv,
          M.map_comp, Category.assoc]
      apply congrArg
      have p := bang_unique (bang ‚äö M.map (SynCat.unit_ty Œµ).to)
      rw [‚Üêp, ‚ÜêCategory.assoc, M.preserve_terminal.leftInv]
      exact Category.id_compose (M.map (SynCat.unit_ty Œµ).to)
    rightInv := by
      apply Eq.trans
      apply bang_unique
      apply Eq.symm
      apply bang_unique
  }
}

def SynCat_equiv_Struct.inv (M : CCFunctor (SynCat œÉ) ùíû) : Struct œÉ ùíû where
  types œÑ := M.obj (Œµ ,, .base œÑ)
  terms t :=
    let t' : Syn Œµ (Œµ ,, _) := Syn.cons Syn.nil (Quotient.mk' (.base t))
    let h := M.map t'
    (go M _).to ‚äö h ‚äö M.preserve_terminal.inv
